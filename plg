#!/usr/bin/env bash
set -e

hdr() {
    if $SINGLE_LINE; then
        # Clear line and overwrite
        printf "\r%*s" "$(tput cols)" "" >&2
        printf "\r$*" >&2
    else
        printf "$*\n" >&2
    fi
}

gitcmd() {
    local repopath="$1"
    local subcmd="$2"
    local output=
    local r=

    set +e
    if [ "$subcmd" = clone ]; then
        output=$(git $subcmd ${@:3} "$repopath" 2>&1)
        r=$?
    else
        output=$(git -C "$repopath" $subcmd ${@:3} 2>&1)
        r=$?
    fi
    set -e

    # shellcheck disable=SC2181
    if [ $r != 0 ]; then
        hdr "${repopath##"$PLG_PREFIX/"}: \033[91m${subcmd^} failed\033[0m"
        $SINGLE_LINE && echo
        echo "$output"
    else
        echo -n "$output"
    fi
    return $r
}

hide_cursor() { printf '\033[?25l'; }

# shellcheck disable=SC2329
show_cursor() { printf '\x1b[?25h'; }

usage() {
    local ansi_h1=$(printf "\033[1;4m")
    local ansi_h2=$(printf "\033[1m")
    local reset=$(printf "\033[0m")
    cat << EOF >&2
Usage: plg [OPTIONS] <COMMAND>

${ansi_h1}COMMANDS:${reset}
  ${ansi_h2}sy(nc)${reset}        Sync and patch all plugins
  ${ansi_h2}st(atus)${reset}      Show status
  ${ansi_h2}c(lean)${reset}       Delete stray pacakges
  ${ansi_h2}p(atch)${reset}       Apply patches onto all plugins
  ${ansi_h2}u(npatch)${reset}     Unpatch all plugins

${ansi_h1}OPTIONS:${reset}
    ${ansi_h2}-j${reset}          Job count for syncing [default: $PLG_JOBS]
    ${ansi_h2}-s${reset}          Print output on single line

${ansi_h1}ENVIRONMENT:${reset}
  ${ansi_h2}PLG_PLUGINS${reset}          Path to configuration file, should export PKGS=() and optionally PATCHES=()
  ${ansi_h2}PLG_PREFIX${reset}           Path to clone repositories into, needs to be on runtimepath
  ${ansi_h2}PLG_PATCHDIR${reset}         Path to patches

EOF
    exit 1
}

job_unpatch() {
    local output
    local name="$1"
    local repo="$PLG_PREFIX/$(basename $name)"
    if [ ! -d "$repo" ]; then
        return
    fi

    output=$(gitcmd $repo checkout .) || return $?
    if [ "$output" != "Updated 0 paths from the index" ]; then
        hdr "$name: \033[${GREEN}m$output\033[0m"
    fi

    # Skip parser*/ directories for nvim-treesitter
    output=$(gitcmd $repo clean \
        --exclude=parser \
        --exclude=doc/tags \
        --exclude=tsst.nvim \
        --exclude=.testenv \
        --exclude=debugger.lua \
        --exclude=parser-info \
        --exclude=.tags \
        --exclude=.luarc.json \
        -fdx) || return $?

    if [ -n "$output" ]; then
        hdr "$name: \033[${GREEN}m$output\033[0m"
    fi
}

job_sync_repo() {
    local remotepath="$1"

    if [[ "$remotepath" == *://* ]]; then
        local url="$remotepath"
    else
        local url="https://github.com/$remotepath"
    fi

    mkdir -p "$PLG_PREFIX"
    local outdir="$PLG_PREFIX/$(basename $remotepath)"

    if [ -d "$outdir" ]; then
        # The return value from the subshell is not caught if we define
        # the variable with `local` on the same line...?
        local output
        output=$(gitcmd $outdir pull) || return $?

        # Print which commit we are updating to if applicable, otherwise
        # use the first line from the output.
        local outstr=$(grep -E '^Updating ' <<< "$output")
        if [ -z "$outstr" ]; then
            outstr=$(sed -n '1p' <<< "$output")
        fi
        hdr "$remotepath: \033[${GREEN}m$outstr\033[0m"
    else
        local git_ref
        gitcmd $outdir clone -c advice.detachedHead=false --depth $PLG_CLONE_DEPTH "$url"
        git_ref=$(gitcmd $outdir rev-parse --short HEAD) || return $?
        hdr "$remotepath: \033[${GREEN}mCloned $git_ref\033[0m"
    fi
}

plg_sync() {
    local i=0
    local pids=()
    for pkg in ${PKGS[@]}; do
        job_sync_repo $pkg &
        pids+=($!)

        # Clone PLG_JOBS repos at a time
        if [ $((i % PLG_JOBS)) = $((PLG_JOBS - 1)) ]; then
            for p in ${pids[@]}; do wait $p || RET=$?; done
        fi
        i=$((i + 1))
    done

    for p in ${pids[@]}; do wait $p || RET=$?; done

    plg_patch

    # Update help tags
    nvim \
        --headless \
        -c 'lua ok, _ = pcall(vim.cmd.helptags, "ALL")
            if ok then vim.cmd.quit() else vim.cmd.cquit() end'
}

plg_unpatch() {
    for pkg in ${PKGS[@]}; do
        job_unpatch $pkg || RET=$?
    done
}

plg_patch() {
    [ -z "${PATCHES[*]}" ] && return

    for p in ${PATCHES[@]}; do
        gitcmd $PLG_PREFIX/$p apply "$PLG_PATCHDIR/$(basename "$p").patch"
        local remotepath="$(tr ' ' '\n' <<< "${PKGS[*]}" | grep "$p$")"
        hdr "$remotepath: \033[${GREEN}mPatched successfully\033[0m"
    done
}

plg_status() {
    for pkg in ${PKGS[@]}; do
        local repo="$PLG_PREFIX/$(basename "$pkg")"
        if [ -z "$repo" ]; then
            echo "Not found: $pkg" >&2
            continue
        fi

        # * Try tag name
        local refname=$(git -C $repo tag --points-at HEAD 2> /dev/null | head -n1)
        # * Try branch name
        [ -z "$refname" ] &&
            local refname=$(git -C $repo symbolic-ref --short HEAD 2> /dev/null)
        [ -n "$refname" ] && refname="[$refname]"
        printf "$pkg \033[${GREEN}m$refname\033[0m\n" >&2

        git -c color.status=always -C "$repo" status -s
    done
}

plg_clean() {
    local cleaned=false
    for d in "$PLG_PREFIX"/*; do
        local name=$(basename $d)
        if ! grep -qE "/${name}\s+" <<< "${PKGS[*]} "; then
            echo "Removing stray package: $name"
            rm -rf ${d}
            cleaned=true
        fi
    done
    $cleaned || echo "No stray packages"
}

################################################################################

# Exports PKGS and PATCHES
PLG_PLUGINS=${PLG_PLUGINS:-$HOME/.config/nvim/plugins.sh}
PLG_PATCHDIR="${PLG_PATCHDIR:-$HOME/.config/nvim/patches}"
# Skip support for .../opt/
PLG_PREFIX=${PLG_PREFIX:-"$HOME/.local/share/nvim/site/pack/plg/start"}
PLG_CLONE_DEPTH=${PLG_CLONE_DEPTH:-1}
PLG_JOBS=8
SINGLE_LINE=false
GREEN=92
RET=0

# Exit with error insteaf of showing "Username for '...'" dialog
export GIT_TERMINAL_PROMPT=0

# shellcheck disable=SC1090
source "$PLG_PLUGINS"

trap show_cursor INT EXIT

while getopts ":hj:s" opt; do
    case $opt in
    j) PLG_JOBS=$OPTARG ;;
    s) SINGLE_LINE=true ;;
    *) usage ;;
    esac
done

shift $((OPTIND - 1))

mkdir -p $PLG_PREFIX

case "$1" in
sy*)
    hide_cursor
    plg_unpatch
    plg_sync
    $SINGLE_LINE && echo
    plg_clean
;;
u*)
    hide_cursor
    plg_unpatch
    $SINGLE_LINE && echo
;;
st*) plg_status ;;
p*) plg_patch ;;
c*) plg_clean ;;
*) usage ;;
esac

exit $RET
